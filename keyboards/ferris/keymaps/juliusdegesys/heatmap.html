<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ferris Sweep Heatmap</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, 'SF Mono', 'Menlo', monospace;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 30px 20px;
  }
  h1 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 6px;
    color: #fff;
  }
  .subtitle {
    font-size: 13px;
    color: #888;
    margin-bottom: 24px;
  }
  .live-dot {
    display: inline-block;
    width: 8px; height: 8px;
    border-radius: 50%;
    background: #4caf50;
    margin-left: 8px;
    margin-right: 3px;
    vertical-align: middle;
    animation: pulse 2s infinite;
  }
  .live-info {
    font-size: 11px;
    color: #666;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Individual keys */
  .key {
    position: absolute;
    width: 52px;
    height: 52px;
    border-radius: 7px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-weight: 600;
    border: 1px solid rgba(255,255,255,0.08);
    transition: transform 0.1s, box-shadow 0.1s;
    cursor: default;
    user-select: none;
  }
  .key:hover {
    transform: scale(1.12);
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    z-index: 10;
  }
  .key .label {
    font-size: 12px;
    line-height: 1.1;
    text-align: center;
    max-width: 46px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .key .hits {
    font-size: 10px;
    opacity: 0.7;
    margin-top: 2px;
  }
  .key.empty {
    opacity: 1;
  }
  .key.thumb {
    width: 58px;
    height: 46px;
    border-radius: 9px;
  }

  /* Stats bar */
  .stats {
    width: 700px;
    background: #252540;
    border-radius: 8px;
    padding: 16px 20px;
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 8px;
  }
  .stat-item { color: #aaa; }
  .stat-item strong { color: #fff; }

  /* Color legend */
  .legend {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 20px;
    font-size: 12px;
    color: #888;
  }
  .legend-bar {
    width: 200px;
    height: 12px;
    border-radius: 3px;
    background: linear-gradient(to right,
      #2a2a4a,
      #1a3a5c,
      #1a6b5a,
      #5a8a2a,
      #c8a520,
      #d06020,
      #c03030
    );
  }

  /* All-layers grid */
  .all-layers {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 20px;
  }
  .all-layers .layer-card {
    background: #20203a;
    border-radius: 10px;
    padding: 14px 16px 12px;
    border: 2px solid transparent;
    transition: border-color 0.15s;
  }
  .all-layers .layer-card.active-layer {
    border-color: #7c6ef0;
  }
  .all-layers .layer-card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 8px;
  }
  .all-layers .layer-card-name {
    font-size: 14px;
    font-weight: 700;
    color: #ccc;
  }
  .all-layers .layer-card.active-layer .layer-card-name {
    color: #7c6ef0;
  }
  .all-layers .layer-card-count {
    font-size: 12px;
    color: #666;
  }
  .all-layers .mini-keyboard {
    position: relative;
    transform: scale(0.70);
    transform-origin: top left;
  }
  .all-layers .mini-keyboard .key {
    transition: none;
  }
  .all-layers .mini-keyboard .key:hover {
    transform: none;
    box-shadow: none;
  }

  /* No data state */
  .no-data {
    text-align: center;
    color: #666;
    padding: 40px 0;
    font-size: 14px;
  }
  .no-data .demo-link {
    color: #7c6ef0;
    cursor: pointer;
    text-decoration: underline;
    margin-top: 8px;
    display: inline-block;
  }
</style>
</head>
<body>

<h1>Ferris Sweep Heatmap</h1>
<p class="subtitle">Dvorak 34-key layout &mdash; juliusdegesys <span id="liveStatus"></span></p>

<div class="all-layers" id="allView"></div>

<div class="stats" id="stats"></div>
<input type="file" id="fileInput" accept=".txt,.log" style="display:none;">

<script>
// Physical key positions for Ferris Sweep (in pixels, key unit = 58px)
const U = 58; // key unit size including gap
const GAP = 2.8 * U; // gap between halves

// Column stagger offsets (vertical, in key units)
const COL_STAGGER = [0.4, 0.15, 0, 0.1, 0.22];

// Build key positions: [row, col] -> {x, y, side}
const KEY_POS = {};

// Left half: rows 0-2 (cols 0-4), row 3 (cols 0-1 = thumbs)
for (let r = 0; r < 3; r++) {
  for (let c = 0; c < 5; c++) {
    KEY_POS[`${r},${c}`] = {
      x: c * U,
      y: (r + COL_STAGGER[c]) * U,
      side: 'left'
    };
  }
}
// Left thumbs
KEY_POS['3,0'] = { x: 3.0 * U, y: 3.45 * U, side: 'left', thumb: true };
KEY_POS['3,1'] = { x: 4.1 * U, y: 3.65 * U, side: 'left', thumb: true };

// Right half: rows 4-6 (cols 0-4), row 7 (cols 0-1 = thumbs)
// Mirrored: col 0 = inner (index), col 4 = outer (pinky)
for (let r = 4; r < 7; r++) {
  for (let c = 0; c < 5; c++) {
    const mirrorCol = 4 - c;
    KEY_POS[`${r},${c}`] = {
      x: (5 * U) + GAP + (c * U),
      y: ((r - 4) + COL_STAGGER[mirrorCol]) * U,
      side: 'right'
    };
  }
}
// Right thumbs
KEY_POS['7,0'] = { x: (5 * U) + GAP + 0.9 * U, y: 3.65 * U, side: 'right', thumb: true };
KEY_POS['7,1'] = { x: (5 * U) + GAP + 2.0 * U, y: 3.45 * U, side: 'right', thumb: true };

// Key labels per layer, keyed by "row,col"
const KEY_LABELS = {
  0: { // DEF
    '0,0':'ESC','0,1':',','0,2':'.','0,3':'P','0,4':'Y',
    '4,0':'F','4,1':'G','4,2':'C','4,3':'R','4,4':'L',
    '1,0':'A','1,1':'O','1,2':'E','1,3':'U','1,4':'I',
    '5,0':'D','5,1':'H','5,2':'T','5,3':'N','5,4':'S',
    '2,0':';','2,1':'Q','2,2':'J','2,3':'K','2,4':'X',
    '6,0':'B','6,1':'M','6,2':'W','6,3':'V','6,4':'Z',
    '3,0':'NAV','3,1':'SHFT',
    '7,0':'SPC','7,1':'SYM',
  },
  1: { // SYM
    '0,0':'~','0,1':"'",'0,2':'"','0,3':'&','0,4':'#',
    '4,0':'+','4,1':'!','4,2':'?','4,3':'@','4,4':'*',
    '1,0':'|','1,1':'{','1,2':'[','1,3':'(','1,4':'<',
    '5,0':'>','5,1':')','5,2':']','5,3':'}','5,4':'',
    '2,0':'`','2,1':'_','2,2':':','2,3':'\\','2,4':'=',
    '6,0':'-','6,1':'%','6,2':'^','6,3':'$','6,4':'/',
    '3,0':'','3,1':'',
    '7,0':'','7,1':'',
  },
  2: { // NAV
    '0,0':'\u2318`','0,1':'\u2318\u21e5','0,2':'\u2318\u21e7T','0,3':'\u2318T','0,4':'\u2318\u2423',
    '4,0':'PgUp','4,1':'C\u21e7\u21e5','4,2':'\u2191','4,3':'C\u21e5','4,4':'',
    '1,0':'\u21e7','1,1':'\u2303','1,2':'\u2325','1,3':'\u2318','1,4':'Hypr',
    '5,0':'\u21b5','5,1':'\u2190','5,2':'\u2193','5,3':'\u2192','5,4':'\u232b',
    '2,0':'Undo','2,1':'Cut','2,2':'Copy','2,3':'Paste','2,4':'\u2318\u21e74',
    '6,0':'PgDn','6,1':'\u21e7\u21e5','6,2':'\u21e5','6,3':'','6,4':'Del',
    '3,0':'','3,1':'',
    '7,0':'','7,1':'',
  },
  3: { // NUM
    '0,0':'F8','0,1':'F7','0,2':'F6','0,3':'F5','0,4':'',
    '4,0':'+','4,1':'7','4,2':'8','4,3':'9','4,4':'*',
    '1,0':'F4','1,1':'F3','1,2':'F2','1,3':'F1','1,4':'',
    '5,0':'0','5,1':'4','5,2':'5','5,3':'6','5,4':'\u232b',
    '2,0':'F12','2,1':'F11','2,2':'F10','2,3':'F9','2,4':'',
    '6,0':'-','6,1':'1','6,2':'2','6,3':'3','6,4':'/',
    '3,0':'','3,1':'',
    '7,0':'BOOT','7,1':'',
  },
};

const LAYER_NAMES = {0: 'BASE', 1: 'SYM', 2: 'NAV', 3: 'NUM'};
const LAYER_TAB_ORDER = [0, 2, 1, 3];
const ALL_POSITIONS = Object.keys(KEY_POS);

// State
let posCounts = {0: {}, 1: {}, 2: {}, 3: {}};
let total = 0;
let activeLayer = 0;
let allKeyElements = {0: {}, 1: {}, 2: {}, 3: {}};
let allLayerCards = {};

// Heatmap color interpolation
function heatColor(ratio) {
  // 0 = cool dark, 1 = hot red
  const stops = [
    [0.0,  42,  42,  74],  // dark purple-gray
    [0.15, 26,  58,  92],  // deep blue
    [0.30, 26, 107,  90],  // teal
    [0.50, 90, 138,  42],  // olive green
    [0.70,200, 165,  32],  // gold
    [0.85,208,  96,  32],  // orange
    [1.0, 192,  48,  48],  // red
  ];
  for (let i = 0; i < stops.length - 1; i++) {
    const [t0, r0, g0, b0] = stops[i];
    const [t1, r1, g1, b1] = stops[i + 1];
    if (ratio <= t1) {
      const t = (ratio - t0) / (t1 - t0);
      const r = Math.round(r0 + (r1 - r0) * t);
      const g = Math.round(g0 + (g1 - g0) * t);
      const b = Math.round(b0 + (b1 - b0) * t);
      return `rgb(${r},${g},${b})`;
    }
  }
  return 'rgb(192,48,48)';
}

function textColor(ratio) {
  return ratio > 0.5 ? '#fff' : '#ccc';
}

// Parse a bulk keylog text into posCounts
function parseLog(text) {
  const lines = text.split('\n');
  for (const line of lines) {
    parseLine(line);
  }
}

// Parse a single log line and increment counts on keydown (KD).
// Ignores KU (keyup) for heatmap counts.
function parseLine(line) {
  const idx = line.indexOf('KD:');
  if (idx === -1) return null;
  const part = line.substring(idx);
  const parts = part.split(':');
  if (parts.length >= 5) {
    const layer = parseInt(parts[1]);
    const row = parseInt(parts[2]);
    const col = parseInt(parts[3]);
    const pos = `${row},${col}`;
    if (layer >= 0 && layer <= 3 && pos in KEY_POS) {
      posCounts[layer][pos] = (posCounts[layer][pos] || 0) + 1;
      total++;
      return { layer, pos };
    }
  }
  return null;
}

// Update everything
function renderAll() {
  updateAllLayers();
  updateStats();
}

function updateStats() {
  const stats = document.getElementById('stats');
  if (total > 0) {
    const parts = LAYER_TAB_ORDER.map(l => {
      const n = Object.values(posCounts[l]).reduce((a, b) => a + b, 0);
      const pct = (n / total * 100).toFixed(1);
      return `<span class="stat-item">${LAYER_NAMES[l]}: <strong>${n.toLocaleString()}</strong> (${pct}%)</span>`;
    });
    stats.innerHTML = `<span class="stat-item">Total: <strong>${total.toLocaleString()}</strong></span>` + parts.join('');
  } else {
    stats.innerHTML = '<span class="stat-item">Drop a keylog.txt or run serve_heatmap.py for live data</span>';
  }
}

// Build the all-layers grid view
function initAllLayers() {
  const container = document.getElementById('allView');
  container.innerHTML = '';
  allKeyElements = {0: {}, 1: {}, 2: {}, 3: {}};
  allLayerCards = {};

  // Calculate keyboard dimensions
  let maxX = 0, maxY = 0;
  for (const pos of ALL_POSITIONS) {
    const p = KEY_POS[pos];
    maxX = Math.max(maxX, p.x + (p.thumb ? 58 : 52));
    maxY = Math.max(maxY, p.y + (p.thumb ? 46 : 52));
  }

  for (const l of LAYER_TAB_ORDER) {
    const card = document.createElement('div');
    card.className = 'layer-card';
    allLayerCards[l] = card;

    const header = document.createElement('div');
    header.className = 'layer-card-header';
    const name = document.createElement('span');
    name.className = 'layer-card-name';
    name.textContent = LAYER_NAMES[l];
    const countSpan = document.createElement('span');
    countSpan.className = 'layer-card-count';
    header.appendChild(name);
    header.appendChild(countSpan);
    card.appendChild(header);

    const kb = document.createElement('div');
    kb.className = 'mini-keyboard';
    kb.style.width = maxX + 'px';
    kb.style.height = maxY + 'px';

    const labels = KEY_LABELS[l];
    for (const pos of ALL_POSITIONS) {
      const p = KEY_POS[pos];
      const label = labels[pos] || '';
      const key = document.createElement('div');
      key.className = 'key' + (p.thumb ? ' thumb' : '') + (label === '' ? ' empty' : '');
      key.style.left = p.x + 'px';
      key.style.top = p.y + 'px';
      key.style.background = '#252540';
      key.style.color = '#999';

      const labelSpan = document.createElement('div');
      labelSpan.className = 'label';
      labelSpan.textContent = label;
      key.appendChild(labelSpan);

      const hitsSpan = document.createElement('div');
      hitsSpan.className = 'hits';
      key.appendChild(hitsSpan);

      kb.appendChild(key);
      allKeyElements[l][pos] = { el: key, labelSpan, hitsSpan };
    }

    // Wrapper to contain the scaled keyboard
    const kbWrap = document.createElement('div');
    kbWrap.style.width = (maxX * 0.70) + 'px';
    kbWrap.style.height = (maxY * 0.70) + 'px';
    kbWrap.style.overflow = 'hidden';
    kbWrap.appendChild(kb);
    card.appendChild(kbWrap);

    container.appendChild(card);
  }
}

function updateAllLayers() {
  for (const l of LAYER_TAB_ORDER) {
    const layerCounts = posCounts[l];
    const maxCount = Math.max(1, ...Object.values(layerCounts).length ? Object.values(layerCounts) : [0]);
    const labels = KEY_LABELS[l];
    const layerTotal = Object.values(layerCounts).reduce((a, b) => a + b, 0);

    // Update card header
    const card = allLayerCards[l];
    card.classList.toggle('active-layer', l === activeLayer);
    const countSpan = card.querySelector('.layer-card-count');
    if (layerTotal > 0) {
      const pct = (layerTotal / Math.max(1, total) * 100).toFixed(1);
      countSpan.textContent = `${layerTotal.toLocaleString()} (${pct}%)`;
    } else {
      countSpan.textContent = '';
    }

    // Update keys
    for (const pos of ALL_POSITIONS) {
      const ke = allKeyElements[l][pos];
      if (!ke) continue;
      const label = labels[pos] || '';
      const count = layerCounts[pos] || 0;
      const ratio = maxCount > 0 ? count / maxCount : 0;

      ke.labelSpan.textContent = label;
      ke.el.classList.toggle('empty', label === '');

      if (total > 0 && count > 0) {
        ke.el.style.background = heatColor(ratio);
        ke.el.style.color = textColor(ratio);
        ke.hitsSpan.textContent = count.toLocaleString();
      } else if (total > 0) {
        ke.el.style.background = '#1e1e35';
        ke.el.style.color = '#555';
        ke.hitsSpan.textContent = '';
      } else {
        ke.el.style.background = '#252540';
        ke.el.style.color = '#999';
        ke.hitsSpan.textContent = '';
      }
    }
  }
}

// Demo data
function loadDemo() {
  const weights = {
    0: {'1,2':900,'1,3':700,'5,2':800,'5,0':400,'1,0':650,'1,1':600,'5,4':550,'5,1':500,'5,3':480,'0,3':320,'0,2':310,'0,1':280,'0,4':180,'4,2':250,'4,3':350,'4,0':200,'4,4':380,'4,1':170,'2,2':100,'2,3':120,'6,0':130,'6,1':180,'6,2':150,'6,3':60,'6,4':30,'2,0':80,'2,1':90,'2,4':20,'1,4':550,'0,0':45,'3,0':620,'3,1':410,'7,0':750,'7,1':390},
    1: {'1,3':120,'5,1':110,'1,2':80,'5,2':75,'0,2':60,'0,1':55,'2,2':50,'2,0':40,'0,0':35,'1,1':90,'5,3':85,'1,0':30,'5,0':70,'2,3':25,'0,3':20,'0,4':15,'4,0':45,'6,0':65,'6,4':55,'2,4':40,'2,1':30,'4,1':18,'4,2':12,'4,3':10,'4,4':8,'6,1':6,'6,2':4,'6,3':3,'1,4':28},
    2: {'5,4':280,'5,0':200,'5,1':150,'5,3':145,'5,2':130,'4,2':90,'1,3':100,'1,0':85,'0,1':70,'0,0':55,'1,2':60,'1,1':50,'6,2':45,'2,0':40,'2,2':35,'2,3':30,'2,1':20,'0,2':15,'0,3':12,'0,4':8,'4,0':25,'4,1':18,'4,3':16,'6,0':22,'6,1':10,'6,4':28,'1,4':15,'2,4':5},
    3: {'5,1':30,'5,2':28,'5,3':25,'5,0':22,'4,1':18,'4,2':15,'4,3':12,'6,1':10,'6,2':8,'6,3':6,'6,4':4,'4,0':3,'4,4':2,'5,4':5,'6,0':3,'1,3':7,'1,2':5,'1,1':3,'1,0':2,'0,0':1},
  };
  for (const [layer, keys] of Object.entries(weights)) {
    for (const [pos, count] of Object.entries(keys)) {
      posCounts[parseInt(layer)][pos] = count;
      total += count;
    }
  }
  document.getElementById('uploadZone').querySelector('p').textContent = 'Demo data loaded. Drop a real keylog to replace.';
  renderAll();
}

// File handling (drag-and-drop on page)
function handleFile(file) {
  if (evtSource) { evtSource.close(); evtSource = null; }
  posCounts = {0: {}, 1: {}, 2: {}, 3: {}};
  total = 0;
  const reader = new FileReader();
  reader.onload = (e) => {
    parseLog(e.target.result);
    if (total === 0) {
      alert('No key events found. Make sure the log contains lines like:\nKL:0:1:2:0x002C');
      return;
    }
    document.getElementById('liveStatus').innerHTML =
      `<span class="live-info">&mdash; ${file.name} (${total.toLocaleString()})</span>`;
    renderAll();
  };
  reader.readAsText(file);
}

document.addEventListener('dragover', (e) => e.preventDefault());
document.addEventListener('drop', (e) => { e.preventDefault(); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); });

// SSE streaming
let evtSource = null;
let statsThrottle = null;

function connectSSE() {
  evtSource = new EventSource('/api/stream');
  evtSource.onmessage = (event) => {
    const line = event.data;

    // Layer change event (LL:<layer>)
    const llIdx = line.indexOf('LL:');
    if (llIdx !== -1) {
      const layer = parseInt(line.substring(llIdx + 3));
      if (layer >= 0 && layer <= 3 && layer !== activeLayer) {
        activeLayer = layer;
        for (const l of LAYER_TAB_ORDER) {
          allLayerCards[l]?.classList.toggle('active-layer', l === activeLayer);
        }
      }
      return;
    }

    // Keypress event
    const result = parseLine(line);
    if (result) {
      const layerCounts = posCounts[result.layer];
      const maxCount = Math.max(1, ...Object.values(layerCounts));
      for (const pos of ALL_POSITIONS) {
        const ke = allKeyElements[result.layer][pos];
        if (!ke) continue;
        const count = layerCounts[pos] || 0;
        const ratio = maxCount > 0 ? count / maxCount : 0;
        if (count > 0) {
          ke.el.style.background = heatColor(ratio);
          ke.el.style.color = textColor(ratio);
          ke.hitsSpan.textContent = count.toLocaleString();
        }
      }
    }
    // Throttle stats updates
    if (!statsThrottle) {
      statsThrottle = setTimeout(() => {
        updateStats();
        for (const l of LAYER_TAB_ORDER) {
          const card = allLayerCards[l];
          const layerTotal = Object.values(posCounts[l]).reduce((a, b) => a + b, 0);
          const countSpan = card?.querySelector('.layer-card-count');
          if (countSpan && layerTotal > 0) {
            countSpan.textContent = `${layerTotal.toLocaleString()} (${(layerTotal / Math.max(1, total) * 100).toFixed(1)}%)`;
          }
        }
        document.getElementById('liveStatus').innerHTML =
          `<span class="live-dot"></span><span class="live-info">${total.toLocaleString()} keypresses</span>`;
        statsThrottle = null;
      }, 200);
    }
  };
  evtSource.onerror = () => {
    // SSE connection lost â€” will auto-reconnect
  };
}

// Startup
initAllLayers();
renderAll();

// Try SSE, fall back to demo
fetch('/api/keylog', { cache: 'no-store' })
  .then(resp => {
    if (resp.status === 200) {
      return resp.text().then(text => {
        parseLog(text);
        document.getElementById('liveStatus').innerHTML = total > 0
          ? `<span class="live-dot"></span><span class="live-info">${total.toLocaleString()} keypresses</span>`
          : `<span class="live-dot"></span><span class="live-info">waiting for data</span>`;
        renderAll();
        connectSSE();
      });
    }
    if (resp.status === 204) {
      document.getElementById('liveStatus').innerHTML =
        `<span class="live-dot"></span><span class="live-info">waiting for keylog</span>`;
      connectSSE();
      return;
    }
    throw new Error('not served');
  })
  .catch(() => {
    setTimeout(() => { if (total === 0) loadDemo(); }, 400);
  });
</script>
</body>
</html>
